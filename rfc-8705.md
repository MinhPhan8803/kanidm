### Overview
RFC 8705 specifies authentication options for OAuth2 based on mutual TLS using client certificates. Such a certificate is associated with a private key, which (and only which) can be used to access protected resources. Therefore, outside parties cannot access these resources even if they got hold of the tokens.

### Mutual TLS method
The definition includes 2 ways to use client certificates for authentication: PKI (public key infrastructure) in which the server uses a certificate chain and a single subject name for authentication; or Self Signed Certificate in which a list or source of certificates (registered beforehand) is used for validation by checking if the client owns the associated private keys.

This proposal suggests the latter method is used, with a certificate source as defined by RFC7591 as this provides more flexibility on the client side (rotating certificates without having to register with the server).

An example workflow would look like this:

1. New client registers their certificate source with the server.
2. During authentication, client presents a certificate to the server.
3. Server checks the source for the presented certificate.
4. TLS used to check if client posesses the corresponding private key.
5. If (3) and (4) matches, auth is successful and access token is issued.

### Access tokens
Here is the fun part, the access token can be associated with the certificate after auth is successful, this association should be accessible by the protected resource. This will require a policy such that mutual TLS is always used for all resources all for all clients of some type.

The workflow:
1. The client sends access token to resource, this include a binding to a certificate.
2. The resource checks if the certificate associated with this token matches the certificate used for mutual TLS.
3. If match, provides resource. If not, returns 401.

The definition also provides 2 example methods for this association. This proposal suggests embedding the certificate hash in a JSON Web Token.

### The Rust implementation
Now onto another (less) fun part.

For mutual TLS:
- We will need a database to store certificate sources, and a corresponding type.
- A certificate type will also be needed.
- A module for processing the certificate, and querying the source.
- TLS for checking the private key.

For access tokens:
- A JWT type is needed for sending and receiving the access tokens.
- We need an efficient way to store the auth'd certificate, perhaps through session?
- This will be handled in a module, which will also decode the hash.
- We will also need a way to signify to the resource that mutual TLS is being used, perhaps through a global variable?

Caveat: [This hackernews thread](https://news.ycombinator.com/item?id=24857145) describes RFC 8705 as bad to implement, so, fun stuff.